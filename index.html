<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="http://d3js.org/d3.v5.min.js"></script>
  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
  </style>
</head>

<body>
  <script>

    let getKeys = function(arr){
    // 노드 배열에서 키값을 뽑아 반환하는 함수
        let keys = [];
        for(i in arr){
            keys.push(i);
        }
        return keys;
    }

    let graph2nodes = function(gr){
    // 그래프 타입 배열을 노드 타입 배열로 변환
        let nodes = [];
        for(i in gr["nodes"]){
            nodes.push({"id":i, "stmt":gr["nodes"][i][0]});
        }
        return nodes;
    }

    let graph2links = function(gr){
    // 그래프 타입 배열을 링크 타입 배열로 변환
        let links = [];
        for(i in gr["edges"]){
            links.push({"source":gr["edges"][i][0], "target":gr["edges"][i][1]});
        }
        return links;
    }

    var svg = d3.select("body").append("svg")
      .attr("width", 960)
      .attr("height", 500);
    
    var graph2 = {
    "nodes": [
        {
            "id": "18362286",
            "lotid": "TEST",
            "epoch": 1511295513000,
            "group": "TEST",
            "sourceOnly": true
        }
    ],
    "links": [
        {
            "source": "18362286",
            "target": "18362287",
            "reltype": "GENEALOGY"
        }
    ]
};

        d3.json("a(cfg).json")
        .then(function(data){

          console.log('json data >>>', data["cfgs"]["main"]);

        let graph = data["cfgs"]["main"];

        /* 
        Graph format
        Node
        {
            "id": "19179458",
            "lotid": "TEST",
            "epoch": 1512051891000,
            "group": "TEST",
            "sourceOnly": false
        }
        Link
        {
            "source": "18362286",
            "target": "18362287",
            "reltype": "GENEALOGY"
        }         ​
        edges: (12) […]
            0: (2) […]
                0: "16" -> SOURCE
                1: "10" -> TARGET
                length: 2
        nodes: {…}
            6: (3) […] -> ID
                0: "return 0" -> LOT_ID
                1: false
                2: false
                length: 3
        */

        console.log('graph >>>', graph);

        let nodeKeys = getKeys(graph["nodes"]);
        let edgeKeys = getKeys(graph["edges"]);

        let width = 960,
            height = 500;
    
        let nodes = graph2nodes(graph);
        let links = graph2links(graph)

        console.log(graph2nodes(graph));
        console.log(graph2links(graph));
        console.log(graph2.nodes);
        console.log(graph2["links"]);

        let simulation = d3.forceSimulation()
            .nodes(nodes);                          

        simulation
            .force("charge_force", d3.forceManyBody().strength(-100))    
            .force("center_force", d3.forceCenter(width / 2, height / 2))
            .force("links", d3.forceLink(links).id(function (d) { return d.id; }))            
            .force("collide", d3.forceCollide().radius(2))
            ;         

        simulation
            .on("tick", ticked);

        //add encompassing group for the zoom 
        var g = svg.append("g")
            .attr("class", "everything");

        //Create deffinition for the arrow markers showing relationship directions
        g.append("defs").append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 -3 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .append("svg:path")
            .attr("d", "M0,-5L10,0L0,5");        

        var link = g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(links)
            .enter().append("line")
            .attr("stroke", function(d) { return d3.color("#000000"); })
            .attr("marker-end", "url(#arrow)");

        var node = g.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .enter()
            .append("circle")
            .attr("r", 10)
            .attr("fill", function(d) { 
                /* if (d.sourceOnly) return d3.color("#0000FF"); */
                return d3.color("#FFFF2F"); })
            .style("stroke", function(d) { 
                /* if (d.sourceOnly) return d3.color("#000080"); */
                return d3.color("#FF8D2F"); 
            });

        //add drag capabilities  
        var drag_handler = d3.drag()
            .on("start", drag_start)
            .on("drag", drag_drag)
            .on("end", drag_end);	

        drag_handler(node);

        var text = g.append("g").attr("class", "labels").selectAll("g")
            .data(nodes)
            .enter().append("g")
            .append("text")
            .attr("x", 14)
            .attr("y", ".31em")
            .style("font-family", "sans-serif")
            .style("font-size", "0.7em")
            .text(function (d) { return d.id + ":" + d.stmt; });

        node.on("click", function (d) {
            d3.event.stopImmediatePropagation();
            self.onNodeClicked.emit(d.id);
        });

        node.append("title")
            .text(function (d) { return d.id + ":" + d.stmt; });
        
        //add zoom capabilities 
        var zoom_handler = d3.zoom()
            .on("zoom", zoom_actions);

        zoom_handler(svg); 

        //Drag functions 
        //d is the node 
        function drag_start(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        //make sure you can't drag the circle outside the box
        function drag_drag(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }
        
        function drag_end(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        //Zoom functions 
        function zoom_actions(){
            g.attr("transform", d3.event.transform)
        }
        
        function ticked() {
            //update circle positions each tick of the simulation 
            node
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });
                
            //update link positions 
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            text
                .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; });
        }


        });

  </script>
</body>